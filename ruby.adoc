:source-highlighter: pygments
:source-language: ruby
:doctype: book
:icons: font
:toc:
:sectnums:

= Programming Ruby
Marek Hulán; Marek Jelen; Ivan Nečas
v0.1, October 14, 2016: First incarnation

## Instalation

### Linux

TIP: Do not use prepackaged Ruby on Linux distributions.

On Linux use https://github.com/rbenv/rbenv[`rbenv`] package manager with the
https://github.com/rbenv/ruby-build[`ruby-build`] extension to install Ruby.

### Windows

For windows there is an installer https://rubyinstaller.org/downloads/[Ruby Installer]
simplifies the installation to the "windows standard approach".

### macOS

The simplest way to install Ruby on macOS is to use `homebrew` package manager

[source,bash]
----
$ brew install ruby
----

in case there is a need to have multiple installations
https://github.com/rbenv/rbenv[`rbenv`]
is a good tool to use. Another popular tool is called `rvm` but nowadays they do too
much magic and we recommend using `rbenv` instead.

## Running Ruby

TIP: Usually you put `ruby` and relates command on PATH so you do not need to always
specify the whole path to the executable. With tools like `rbenv` this is done for you.

[source,bash]
----
$ ruby -v
----

runs Ruby and prints it's version. Simplest way to verify that your instalation
works as expected.

[source,bash]
----
$ ruby script.rb
----

interprets the script.rb. However instead of running the script explicitly, you can
add the shebang line to your script

[source,bash]
----
#!/usr/bin/env ruby
----

and make it executable (`chmox +x script.rb`) and run it simply as `./script.rb`.

### Interactive Ruby

Ruby comes with an interactive interpreter called `irb` it allows you to enter commands
and see results instantly.

[source,bash]
----
$ irb
----

## About Ruby

Ruby a programming language with following aspects

### Interpreted

The Ruby code is interpreted when the script is load, there is no compile phase.

### Universal

Ruby can be used for writing scripts, one-liners, web applications and even for mobile and desktop
applications.

### Fully Object oriented

In Ruby everything is an object and you send messages to those objects.

### Everything is an expression

Everything command in Ruby has a return value.

### Atomic memory management

### MRI

`MRI` is the Ruby reference implementation, with several other implementations like `JRuby`, `Rubinius`,
`IronRuby` or `MagLev`. As well, there is ISO standard implemented in `mruby`.

### Strongly typed

There are some implicit conversions (e.g. every object has `to_s` method to provide
string representation) but in most cases in case you try to operate on different types
Ruby will complain, unless such operation is explicitly provided.

[source]
----
5 + "a" # => TypeError: String can't be coerced into Fixnum
----

### Dynamically typed

The type of a variable is defined by the value assigned to that variable. There is no explicit type
information in the code.

[source]
----
a = "string"
----

### What is written in Ruby?

* programming languages: Ruby (Rubinius), compilers (LessJS)
* web applications: Github, Twitter
* devops tools: Puppet/Chef/Vagrant
* cloud platforms: OpenShift (v2)
* cloud management: DeltaCloud
* VIM/Emacs scripts
* static pages generators - Jekyll
* programming tools


## Conventions

* class names are CamelCase
* file names reflect class names in snake_case format
* method names are snake_case
* constants are UPPER_CASE
* indent by 2 spaces
* methods returning boolean values end with `?`
* methods mutating state end with `!`

## Basic syntax

Basic and most explicit syntax looks like

[source]
----
puts("hello world!");
----

However the parenthesis are optional in case the only one interpretation of the
expression

[source]
----
puts "hello world!";
----

and semicolons are optional as well

[source]
----
puts "hello world!"
----

String use either quotation marks `"` or apostrophes `'`. Apostrophes does not provide
string substitution as quotations marks do.

[source]
----
a = 'Hello'      # => "Hello"
b = "#{a} world" # => "Hello world"
b = '#{a} world' # => "\#{a} world"
----

### Operator priority

### Special characters in method names

Ruby allows usage of special characted in method names. The standard is to use

* the question mark `?` for methods that return boolean value
* the exclamation mark `!` for methods that mutate the object

[source]
----
1.even?                 # => false
"ruby".upcase.reverse   # => 'YBUR'
"ruby".size.even?       # => true
----

### Comments

In the code above the single line comment is used. It starts with hash `#` and follows
to the end of the line. In case of commenting multiple lines, it is customary to
comment every line with single line comment.

[source]
----
# you should
# do this
# to comment
# multiple lines
----

## Data types

As mentioned above in Ruby everything is an object, including arrays or numbers.
However there are special syntax shorthands to create instances of special classes.

### Strings

As mentioned above String are create by quoting the charachters

[source]
----
a = "string"
b = 'string'
----

### Numbers

Ruby has two basic number classes `Fixnum` and `Float`.

[source]
----
a = 1   # => 1
a.class # => Fixnum

b = 1.1 # => 1.1
b.class # => Float
----

### Empty value

Special value that represents "nothing" is `nil`.

[source]
----
a = nil # => nil
----

In a boolean expression, `nil` is considered false, i.e. it's only of two possible
values that are not considered true.

### Booleans

As usual there is either `true` or `false`.

[source]
----
a = true   # => true
b = false  # => false
a && b     # => false
a || b     # => true
----

### Arrays

Arrays is an ordered sequence of values. There are no restrictions on what types can
be in a single array.

[source]
----
["a", 1, true] # => ["a", 1, true]
----

### Hashes

Hash is a structure that maps key to a value.

[source]
----
{"a" => true, "b": false} # => {"a"=>true, :b=>false}
----

There are two approaches how to write the mapping, either `rocket` style

[source]
----
key => value
----

or `json` style

[source]
----
key: value
----

You can use both syntaxes, however with the `json` style the value is converted
to `symbol`, so in case you need to use `String` or some other type, or get the name
of the key from a variable, you need to use the `rocket` style. Several well-known
coding guidelines recommend (and enforce) using `rockets` everywhere.

### Symbols

Symbol is a keyword. It always maps to the same object instance

[source]
----
a = "a" # => "a"
b = "a" # => "a"

a.object_id # => 70224766839340
b.object_id # => 70224750415480

a = :a # => :a
b = :a # => :a

a.object_id # => 722268
b.object_id # => 722268
----

## Objects and methods

Methods are called by using the `.`. Operators are actually methods.

[source]
----
3 + 3  # => 6
3.+(3) # => 6

[1,2][0]    #=> 1
[1,2].[](0) # => 1
----

## Variables

Ruby has global variables prefixed by `$`.

[source,ruby]
----
$stdout
----

Classes and object can use class variables, though there are no used very much.

[source,ruby]
----
@@class_variables = 1
----

Objects have instance variables.

[source,ruby]
----
@instance_variable = 1
----

Local variables have no prefix.

[source,ruby]
----
local_variable = 1
----

And finally constants are all upper case.

[source,ruby]
----
CONSTANT = 1
----

## Conditions

Everything is considered `true` except `false` and `nil`.

[source,ruby]
----
a = nil
b = ""

if a
  "we do not get in here"
elsif b
  "we got here"
else
  "we did not get here"
end
----

Ruby has negative variant to `if` called `unless`. Essentially `unless bool_expr` is
equivalent to `if !(bool_expr)`. It is used the same way as normal `if`.

[source,ruby]
----
a = nil
b = ""

unless a
  "we do get in here"
elsif b
  "we did not get here"
else
  "we did not get here"
end
----

Ruby has inline method of using conditionals called modifier statements.

[source,ruby]
----
puts "Hello" if true
puts "Hello" unless false
----

Ternary operator is available as well.

[source,ruby]
----
experssion ? 'was evaluated true' : 'was evaluated false'
----

Another way to do conditions is to use `case` statement.

[source,ruby]
----
case input
  when 'q', 'e'
    quit
  when 'f'
    format
  else
    help
end
----

`Case` statement can as well check on variable class.

[source,ruby]
----
case var
  when String
    "it's string"
  when Class
    "it's class"
  when Number
    "it's number"
end
----

Another way to use `case` statement is to use it as `if` and `elsif`.

[source,ruby]
----
case
  when a == "a"
    "a equals a"
  when b == "b"
    "b equals b"
end
----

## Logical operators

There are basic logical expressions

* and `&&`
* or `||`
* not `!`

as well `&&` can be replaced with `and`, `||` can be replaced with `or` and `!` can
be replaced with `not`.

There are basic comparison operators

* equal `==`
* not equal `!=`
* lesser then `<`
* greater then `>`
* lesser then or equal `>=`
* greater then or equal `<=`
* regular expersion match `=~`

## Regular expressions

Regular expressions are enclosed with `/`. The simplest way is to use the regexp
operator.

[source,ruby]
----
string = 'localhost:2000'
string =~ /.*:.+/     # 0
string =~ /(.)*:(.)+/ # sets $1 a $2
----

as well there is a `match` method on string.

[source,ruby]
----
data = string.match(/^(.):(\d+)$/)
data[1] # => localhost
data[2] # => 2000
----

## Loops

`while` repeats as long as the condition is true.

[source,ruby]
----
while a < b
  a += 1
end
----

To go through the body of the loop at least once

[source,ruby]
----
begin
  a += 1
end while a < b
----

There is as well inline way to write the loop

[source,ruby]
----
a += 1 while a < b
----

And finally the negative counterpart `until`

[source,ruby]
----
until a > b
  a += 1
end
----

## Methods

Methods in Ruby always return some value. If it is not explicitly returned using the
`return` keyword, the return value is the value of the last expression in the method.
Return as usual returns from method and ends the execution of the method.

[source,ruby]
----
# Simple method with two arguments
def mth(a, b)
end

# Method with default value for 2nd argument
def mth(a, b=1)
end

# Method accepting any number of arguments, available as Array args
def mth(*args)
end

# Method requiring at least two arguments
def mth(a, b, *args)
end
----

## Reusing code from other files

The `require` method loads code from another file. Ruby keeps track of required files
and skips loading files that would be loaded 2nd time. Files are looked up using Ruby's
load path, which is represented using an array in `$LOAD_PATH` and `$:`. The `load` method does
not keep track of loaded files.

In case the required file ends with [rb, so, o, dll, bundle, jar] extension, the extension
may be omitted. There two commands are equivalent

[source]
----
require "somefile"
require "somefile.rb"
----

To keep track of required files, Ruby keep list of all files that were required in the `$"`
variable.

## Blocks

Blocks have many uses-cases. One of the use cases is the replacement for `for` cycles
another use case is `anonnymous functions`. Block are not executed when defined, but
needs to be called using the `call` method (though the calling of `call` method is
most of the times hidden from the develop as in the example below).

Arrays have method called `each` that accepts block and calls the block for every
single element in the array.

[source,ruby]
----
arr = [1,2,3,4]
arr.each do |el|
  puts el
end
----

will print all four values to the standard output. Block have another possibility

[source,ruby]
----
arr = [1,2,3,4]
arr.each { |el| puts el }
----

this variant is usually used for single-line blocks.

Block see their own scope plus can access scope in which were defined.

[source,ruby]
----
sum = 0
arr = [1,2,3,4]
arr.each { |el| sum += el }
----

Any method can accept a block and call it

[source]
----
def mth
  return nil unless block_given?
  yield
end
----

This method will return nil if no block was given or will call the block without any
argument and the return value of the block will be return from the method.

Method may also accept blocks as a named argument which is prefixed by `&`.

[source,ruby]
----
def mth(num,&block)
  block.call(num)
end
----

this method will call block saved in the variable `block` and will pass one argument
which is the argument passed to the method itself.

## Objects

In Ruby everything is an object. Object is an instance of some class. Even every class
is an instance of class that inherits from Class. Object can have methods

[source,ruby]
----
class Hello
  def say
    "Hello, world!"
  end
end

puts Hello.new.say
----

and instance variables

[source,ruby]
----
class Hello
  def initialize(msg=nil)
    @msg = msg
  end

  def say
    @msg
  end
end

puts Hello.new("Hello, world!").say
----

To make your instance variables accessible from outside, you define them as attributes.
Attributes can be either read-only, write-only or both.

[source,ruby]
----
class Hello
  attr_reader :one       # allows reading by using the .one method
  attr_writer :two       # allows writing by using the .two = "xy" method
  attr_accessor :three   # allows both, reading and writing
end
----

## Inheritance

Ruby allows object inheritance. All methods including constructor are inherited. Methods
can be overridden by children. `super` is then used to call the original method.

[source,ruby]
----
class A
  def a
    "hello"
  end
end

puts A.new.a # => hello

class B < A
end

puts B.new.a # => hello

class C < A
  def a
    super + " world"
  end
end

puts C.new.a # => hello world
----

## Class methods and attributes

As known from other language, except in Ruby class variables are not used because of
some pitfalls in their inheritance.

[source,ruby]
----
class A
  def self.a
    "hello"
  end
end

puts A.a # => hello
----

## Monkey patching

Ruby allows you to `open` already defined classes and change their definition including
replacement of methods. However `with great power comes great responsibility`.

[source]
----
"hello".upcase # => HELLO

class String
  def upcase
    "*" * self.size
  end
end

"hello".upcase # => *****
----

## Modules

Modules are a way to organize your classes in a similar fashion to namespaces. Classes
can be included into modules or into other classes.

[source]
----
class A
  class B
  end
end

module Some
  class Thing
  end
end
----

Module are however used as well as mixins. When module is included into class all
methods defined for that module are available in the class as instance methods.

[source]
----
module Helper
  def something
  end
end

class A
  include Helper
end

A.new.something
----

and when used with `extend` the mehtods are included as class methods

[source]
----
module Helper
  def something
  end
end

class A
  extend Helper
end

A.something
----

Ruby has only single inheritance, mixins allow to get around this and provide a
way to get some kind of multiple inheritance.

## Method access

By default methods are `public`, explicitly methods can be made `protected` or `private`.

[source]
----
class A
  def public_method
  end

  protected

  def protected_method
  end

  private

  def private_method
  end
end
----

The `send` method allows bypassing the privacy of a method. By itself it allows
dynamically calling method.

[source]
----
class A
  def public_method
  end

  private

  def private_method
  end
end

A.new.send(:private_method)
----

## Duck typing

Ruby encourages to react based on behaviour rather then on identity.

[source,ruby]
----
class Hunter
  def shoot(animal)
    bang! if animal.class == Duck
  end
end
----

in this case the code check if it's a duck and shoots it, however

[source,ruby]
----
class Hunter
  def shoot(animal)
    animal.respond_to?(:quack) && bang!
  end
end
----

in this case we care if the animal qucks and the it's shot.

## Method_missing

Every object can define special `methhod_missing` method that is called whenever
there is a call to undefined method on that object.

[source,ruby]
----
class A
  def method_missing(name, *args, &block)
    puts "method #{name} called with args #{args.inspect}"
  end
end

A.new.something("a") # => method something called with args ["a"]
----

## Metaprogramming

Metaprogramming allows you to dynamically work with your program through Ruby code.
Most of the times people use this technique for building DSL (domain specific languages)
in Ruby.

One of the most important aspects of metaprogramming is to understand what an eigenclass
(singleton class) is.

Let's start with something special. In Ruby it's possible to define per object methods.

[source,ruby]
----
string = "hello"

def string.star
  "*" * self.size
end

string.star # => *****

"world".star # => NoMethodError: undefined method `star' for "world":String
----

OK, now the question is, where is the method stored? It can not be on the String class
as it's available only to the specific instance. And instances do not store methods,
only classes do. And the answer is our eigenclass. The closes method to any object is
not it's class but it's eigenclass. So, whenever you define per-object behaviour the
method is stored in it's eigenclass.

https://github.com/municz/study-materials/wiki/Lecture-02[Other material]

## Exceptions

Exceptions represnt a special state in the execution in a program. When an exception
is raised, it will bubling thorugh the stack until is caught.

Exceptions are raised using the `raise` keyword

[source]
----
raise Exception.new("Hello")
----

On the other hand when an exception needs to be caught, code block is extended with
`rescue` statement that is called when an exception is caught and optionally `ensure`
that is called after both exceptional and non-exceptional state.

[source]
----
begin
  raise Exception.new
rescue => e
  puts e.message
ensure
  puts "always"
end
----

# Advanced Ruby & meta-programming

## Return statements

In Ruby every code is executable - it is an expression. By definition an expression should have
some return value - the result of it's execution. Let's take a look at this example

[source]
----
class A
end
----

What is the result of such an expression? You might say "we defined class A". But it is not. The
fact we defined a class is only an effect of the expression but not the result, result is a value
returned from the expression itself.

[source]
----
var = nil
var.inspect # => nil

var = class A
end

var.inspect # => nil
----

The value has not changed .... there is no resulting value. Wrong again! The resulting value was
simply nil, the same value as in the variable, but it was returned.

[source]
----
var = nil
var.inspect # => nil

var = class A
  self
end

var.inspect # => A
----

In this example we get a return value. As we can see, it is a class A. How is that possible?
Because the last line of a method is return value. Do you remember? Basically we can generalize to

----
last line of an expression is it's return value.
----

## Context

As said before, everything in executed in some context. This context is know as current object and
is always represented by self.

[source]
----
self.class # => Object

class B
  self
end
# => Class

class A
  def call
    self
  end
end

A.new.call # => #<A:some number>
----

## Class

### Open classes

Unlike most languages, Ruby classes are open for modifications. This way programmer can modify behavior
of classes defined by frameworks or Ruby itself. This technique is called `Monkey patching`.

[source]
----
class Clazz
  def call
    "A"
  end
end

class Clazz
  def call
    "B"
  end
end

Clazz.new.call # => "B"
----

### What is a class?

People unfamiliar with Ruby might ask, why is the precedent example valid and the answer is simple:

----
classes are instances of class Class
----

everything in Ruby is an object ... even a class. Don't you believe me? Try this example:

[source]
----
class A
  def self.call
    "called"
  end
end

class B
end

def B.call
  "called"
end

C = Class.new

class C
  def self.call
    "called"
  end
end

D = Class.new

def D.call
  "called"
end

A.call # => "called"
B.call # => "called"
C.call # => "called"
D.call # => "called"
----

In the example we defined 4 classes, with class method call that return string "called" all
those 4 techniques are equivalent and you can mix them freely.

### Inheritance

One class can inherit from another. Ruby has only single-class inheritance - you can not inherit from multiple classes.

[source]
----
class A
 def call
   "called"
 end
end

class B < A
end

C = Class.new(B)

B.new.call # => "called"
C.new.call # => "called"
----

### Mixins

When a class needs to inherit from multiple classes, Ruby allows as to mix in multiple Modules.
Methods of these modules are then available to the class.

[source]
----
module Methods
  def call
    "called"
  end
end

class A
  include Methods
end

A.new.call # => "called"
----

### Class name

Ruby let us get the name of class by calling method name of the class.

[source]
----
Array.name # => "Array"

[].class.name # => "Array"
----

## Methods

As everything else in Ruby even methods are instances of class Method.

### Inspecting methods

Ruby has powerful tools to introspect object. One of the cases is the list of methods of an objects.
The list can be obtained simple by calling method methods.

[source]
----
class A
  def call
  end
end

A.new.methods # => array of methods
----

What's this good for? Let's continue.

### Extracting methods

Sometimes it might be useful to pass around only a method instead of the whole object. Ruby lets you extract a method
for later use.

[source]
----
class A
  def call(arg1)
    self
  end
end

meth = A.new.method(:call) # => #<Method: A#call>
----

This example shows, that we "extracted" method call from class A. The method is bound to the instance of class A -
the method will be evaluated in the context of the object. The method can be executed by calling call method with
appropriate arguments.

[source]
----
meth.call("some string") # => #<A:some_number>
----

From the example is obvious, that the method is executed in the context of the object.

### Checking method existence

Because Ruby is very dynamic language, we can not be always sure what type of argument we receive. Usually the
programmer does not care what class the argument is, but whether the argument response to some method. This is
called Duck typing technique - we do not care what the object is, we only care whether it behaves as we expect.

[source]
----
class A
  def call
  end
end

a = A.new

a.respond_to?(:call) # => true
a.respond_to?(:wtf)  # => false
----

### Dynamic method calling

[source]
----
class A
  def call
  end
end

A.new.call
----

This example shows how to call a method, but there is one big "but". We have to know the name of the methods
beforehand ... in the time we write the code. What if we do not the method name and we need to call it. Do not be
surprised, this is very common use-case in Ruby. The two call to methods call are identical.

[source]
----
class A
  def call(arg1)
  end
end

a = A.new
a.call("some string")
a.send(:call, "some string")
----

Well, not so identical. When you use the send method on an object, you effectively bypass the access modifiers.
This way a developer is allowed to call event protected or private methods.

### Defining methods programmatically

The way to define methods shown before is not the only one. We can also define in a more programmatically way.
It makes sense. We can inspect methods of an object, we can extract methods of an object and also call methods of
an object in a dynamic way.

----
Class.define_method is private
----

[source]
----
class A
end

a = A.new

logic = Proc.new do
  "data"
end

A.send(:define_method, :some_method_name, logic)

a.some_method_name # => "data"
----

## Objects

What is an object? Let's simplify it ... and show you as a contrast to classes

----
objects define state x classes define behavior
----

Object are complements to classes. We define some behavior as a class, then creating an object of the class that
holds some state. Every object has to be of some class.

### Creating new object

To create an object of some class it is used the method new of respective class.

[source]
----
class Dog
end

dog = Dog.new
----

### Defining methods

Previously we defined many methods in simple and fancy styles. But let's get back to the core and try to define a
method

[source]
----
class A
  def call
  end
end
----

here we use def keyword to define method. Where will def define the method? The answer is simple and complex

----
def defines method into the nearest class
----

So in the previous example the nearest class is A. That is obvious from next example when we inspect the self inside
the class.

[source]
----
var = class A; self; end

var.class  # => Class
var.name   # => "A"

A.new.call # => "string"
----

Now let's try to define a class method.

[source]
----
class A
  def self.call
    "string"
  end
end
----

Where will Ruby define the method now?? It is a bit more complicated. To understand this, we have to explain something
else first.

### Eigenclass

To understand how Ruby works, we have to understand what `eigenclasses` are. Let's start with simple definition

----
every object in Ruby has it's own eigenclass => an instance of Class (eigen means "it's own" in German)
----

Why is this important? Because, however the `eigenclass` is basically invisible to Ruby, it takes an important
part in lookup paths.

When Ruby looks up a method a program is calling, it follows a basic chain (we will talk about it a bit later).
Important is, that before the class the object is linked to, there is the object's eigenclass. Now it is important
that the closest class to an object is not it's class but it's eigenclass.

So, back to the example we were talking about

[source]
----
class A
  def self.call
    "string"
  end
end
----

to see it more clearly we can rewrite this example identically as

[source]
----
class A
end

def A.call
  "string"
end
----

these two expressions are identical. To understand why it is important to understand this

[source]
----
class A
end

scope = class A
  self
end

A == scope # => true
----

but back to the original question ... where are we trying to define the method? In the context of the instance of the
class A. The important part is the instance of ... what is the closest class to instance (object)? As stated above
it's eigenclasses. From this point you should see that

----
there are no class methods in Ruby
----

What could be called a class method is only an instance method defined on the eigenclass associated with object
that represents the class itself.

So eigenclass is some stealth object that we can not see? Not really. Ruby has concept to access eigenclasses

[source]
----
eigenclass = class << some_object
  self
end

eigenclass = some_object.singleton_class
----

now that we can access eigenclasses, let's see how we could define "class methods" (instance methods of eigenclass).

[source]
----
class A
  def self.call
    "called"
  end
end

class B
  class << self
    def call
      "called"
    end
  end
end

class C
end

class << C
  def call
    "called"
  end
end

D = Class.new
class << D
  def call
    "called"
  end
end

E = Class.new
def E.call
  "called"
end

F = Class.new
class F
  class << self
    def call
      "called"
    end
  end
end
----

all those examples are identical.

### Method lookups

Now that you know where and how are methods defined, lets see how methods are looked up. Let's see how the class
hierarchy looks for class

----
SomeClass -> Class -> Module -> Object -> BasicObject
----

and for objects

----
object -> SomeClass -> Object -> BasicObject
----

Important thing about eigenclasses is that they are not visible as classes of objects.

[source]
----
o1 = Object.new

def o1.meth
  "string"
end

o1.meth  # => "string"
o1.class # => Object

o2 = Object.new

o2.meth  # => undefined method `meth`
o2.class # => Object
----

This example shows that having two instances of same objects. Both can behave differently. Because in the case of o1
the method is stored in the eigenclass, that is not accessible by o2.

----
Eigenclasses are used when a specific behavior of an object is expected
----

# Testing

## MiniTest

# Standard library

## Files

# Ruby on Rails

## Introduction